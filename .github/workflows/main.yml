name: PRO Stream - Ultimate Version 2026

on:
  workflow_dispatch:  # Manual trigger only
  schedule:
    - cron: '0 */6 * * *'  # Optional: Run every 6 hours

# Prevent workflow conflicts
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  pro_streaming_job:
    runs-on: ubuntu-latest
    timeout-minutes: 240  # 4 hours total (2 + 2)
    
    env:
      STREAM_URL: ${{ secrets.STREAM_URL }}
      VIDEO_FILE: "pro_stream_video.mp4"
      BACKUP_FILE: "backup.mp4"
      TEMP_DIR: "/tmp/pro_stream_${{ github.run_id }}"
      FILE_ID: "1YTmGPf2Zd--xfSDOTGQoui5kyHpTJLu-"  # Updated file ID

    steps:
      - name: Checkout Source Code
        uses: actions/checkout@v4
        with:
          lfs: false
          persist-credentials: false

      - name: ğŸ” Pro Security Environment Setup
        run: |
          # Create secure temporary directory
          mkdir -p "${{ env.TEMP_DIR }}"
          chmod 700 "${{ env.TEMP_DIR }}"
          
          # Store stream key in secure file (not in environment)
          echo "${{ secrets.STREAM_KEY }}" > "${{ env.TEMP_DIR }}/.stream_key"
          chmod 400 "${{ env.TEMP_DIR }}/.stream_key"
          
          # Store configuration
          cat > "${{ env.TEMP_DIR }}/.config" << CONFIG
          FILE_ID=${{ env.FILE_ID }}
          STREAM_URL=${{ env.STREAM_URL }}
          VIDEO_FILE=${{ env.VIDEO_FILE }}
          TEMP_DIR=${{ env.TEMP_DIR }}
          CONFIG
          chmod 400 "${{ env.TEMP_DIR }}/.config"
          
          umask 077
          echo "âœ… Pro security environment initialized"

      - name: ğŸ› ï¸ Install Pro Tools
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            ffmpeg \
            wget \
            bc \
            curl \
            jq \
            netcat \
            procps \
            python3-pip \
            expect \
            parallel \
            htop
          
          pip3 install --quiet --upgrade gdown google-drive-downloader

      - name: ğŸ“¥ Pro Smart Download with Advanced Rate Limiting
        run: |
          echo "ğŸš€ Pro download manager initializing..."
          echo "ğŸ“ File ID: ${{ env.FILE_ID }}"
          
          OUTPUT="${{ env.VIDEO_FILE }}"
          
          # Pro download settings
          MAX_RETRIES=10
          INITIAL_DELAY=10
          MAX_DELAY=120
          RATE_LIMIT_WAIT=300  # 5 minutes for rate limit
          PARALLEL_CHUNKS=4
          
          # Rate limit detection patterns
          RATE_LIMIT_PATTERNS=(
            "too many requests"
            "rate limit"
            "quota exceeded"
            "403"
            "429"
            "cannot download"
            "access denied"
            "drive quota"
          )
          
          check_rate_limit() {
            local error_msg="$1"
            for pattern in "${RATE_LIMIT_PATTERNS[@]}"; do
              if echo "$error_msg" | grep -qi "$pattern"; then
                return 0  # Rate limit detected
              fi
            done
            return 1
          }
          
          # Alternative download methods
          download_with_wget() {
            local file_id="$1"
            local output="$2"
            local confirm=$(wget --quiet --save-cookies /tmp/cookies.txt \
              --keep-session-cookies --no-check-certificate \
              "https://docs.google.com/uc?export=download&id=$file_id" -O- \
              | sed -rn 's/.*confirm=([0-9A-Za-z_]+).*/\1\n/p')
            
            wget --load-cookies /tmp/cookies.txt \
              "https://docs.google.com/uc?export=download&confirm=$confirm&id=$file_id" \
              -O "$output" && rm -rf /tmp/cookies.txt
          }
          
          download_with_curl() {
            local file_id="$1"
            local output="$2"
            curl -L -b /tmp/cookies.txt \
              "https://drive.usercontent.google.com/download?id=$file_id&confirm=t" \
              -o "$output"
          }
          
          # Smart download with multiple methods
          pro_download() {
            local attempt=1
            local delay=$INITIAL_DELAY
            local temp_file="${{ env.TEMP_DIR }}/download_temp_$(date +%s).mp4"
            local download_methods=("gdown" "wget" "curl")
            
            while [ $attempt -le $MAX_RETRIES ]; do
              echo "ğŸ“¡ Pro download attempt $attempt of $MAX_RETRIES..."
              
              # Try different download methods
              for method in "${download_methods[@]}"; do
                echo "  ğŸ”§ Trying method: $method"
                
                case $method in
                  gdown)
                    DOWNLOAD_OUTPUT=$(gdown "https://drive.google.com/uc?id=${{ env.FILE_ID }}" -O "${temp_file}" --fuzzy 2>&1)
                    DOWNLOAD_EXIT=$?
                    ;;
                  wget)
                    download_with_wget "${{ env.FILE_ID }}" "${temp_file}" 2>&1
                    DOWNLOAD_EXIT=$?
                    ;;
                  curl)
                    download_with_curl "${{ env.FILE_ID }}" "${temp_file}" 2>&1
                    DOWNLOAD_EXIT=$?
                    ;;
                esac
                
                if [ $DOWNLOAD_EXIT -eq 0 ] && [ -f "${temp_file}" ] && [ -s "${temp_file}" ]; then
                  # Quick size check
                  local file_size=$(stat -c%s "${temp_file}" 2>/dev/null || stat -f%z "${temp_file}" 2>/dev/null)
                  if [ "$file_size" -lt 1000 ]; then
                    echo "    âš ï¸ File too small ($file_size bytes), probably error page"
                    rm -f "${temp_file}"
                    continue
                  fi
                  
                  # Verify file integrity with ffmpeg
                  echo "    ğŸ” Verifying file integrity..."
                  if ffmpeg -v error -i "${temp_file}" -f null - 2>/dev/null; then
                    echo "    âœ… File integrity verified"
                    mv "${temp_file}" "${OUTPUT}"
                    chmod 644 "${OUTPUT}"
                    echo "âœ… Pro download successful with method $method on attempt $attempt"
                    return 0
                  else
                    echo "    âš ï¸ File corrupted, retrying..."
                    rm -f "${temp_file}"
                  fi
                else
                  echo "    âš ï¸ Download error with method $method"
                  
                  # Handle rate limit
                  if check_rate_limit "$DOWNLOAD_OUTPUT"; then
                    echo "    â³ Rate limit detected! Waiting $RATE_LIMIT_WAIT seconds..."
                    sleep $RATE_LIMIT_WAIT
                    continue 2  # Continue to next method after wait
                  fi
                fi
              done
              
              # Exponential backoff
              if [ $attempt -lt $MAX_RETRIES ]; then
                echo "â³ All methods failed. Waiting $delay seconds before next attempt cycle..."
                sleep $delay
                delay=$((delay * 2))
                [ $delay -gt $MAX_DELAY ] && delay=$MAX_DELAY
              fi
              
              ((attempt++))
            done
            
            return 1
          }
          
          # Execute pro download
          echo "ğŸ“¥ Starting advanced download process..."
          if pro_download; then
            echo "âœ… Pro download completed successfully!"
          else
            echo "âš ï¸ All download attempts failed, checking for backup"
            
            # Try to get from GitHub releases as fallback
            if [ -f "${{ env.BACKUP_FILE }}" ]; then
              cp "${{ env.BACKUP_FILE }}" "${{ env.VIDEO_FILE }}"
              chmod 644 "${{ env.VIDEO_FILE }}"
              echo "âœ… Local backup file deployed"
            else
              echo "âŒ No backup file available!"
              echo "ğŸ” Attempting emergency download from alternative source..."
              
              # Emergency direct download attempt
              curl -L -o "${{ env.VIDEO_FILE }}" "https://github.com/${{ github.repository }}/releases/download/latest/backup.mp4" 2>/dev/null || {
                echo "âŒ Emergency download failed!"
                exit 1
              }
            fi
          fi
          
          # File information and validation
          echo "ğŸ“Š Pro media file info:"
          ls -lh "${{ env.VIDEO_FILE }}"
          
          echo "ğŸ“ Video duration:"
          DURATION=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "${{ env.VIDEO_FILE }}" 2>/dev/null || echo "0")
          echo "$DURATION seconds"
          
          if (( $(echo "$DURATION < 60" | bc -l) )); then
            echo "âš ï¸ Warning: Video duration is less than 1 minute!"
          fi

      - name: ğŸ¬ Pro Secure Stream Wrapper
        run: |
          # Main secure stream script
          cat > pro_secure_stream.sh << 'EOF'
          #!/bin/bash
          
          # PRO VERSION - Enterprise Grade Security
          # Hides stream key from process list
          
          set -e
          
          TEMP_DIR="$1"
          VIDEO_FILE="$2"
          STREAM_URL="$3"
          SEGMENT_DURATION="$4"  # 2 hours in seconds (7200)
          SEGMENT_NUM="$5"  # 1 or 2
          
          # Read key securely from file
          STREAM_KEY=$(cat "${TEMP_DIR}/.stream_key")
          
          # Create unique named pipe for FFmpeg input
          FFMPEG_PIPE="${TEMP_DIR}/ffmpeg_pipe_${SEGMENT_NUM}"
          mkfifo "$FFMPEG_PIPE"
          
          # Create FFmpeg options file
          FFMPEG_OPTS="${TEMP_DIR}/ffmpeg_opts_${SEGMENT_NUM}.txt"
          
          # Build optimized FFmpeg command
          cat > "$FFMPEG_OPTS" << 'INNER'
          -hide_banner
          -loglevel
          error
          -re
          -stream_loop
          -1
          -i
          INNER
          
          echo "$VIDEO_FILE" >> "$FFMPEG_OPTS"
          
          cat >> "$FFMPEG_OPTS" << 'INNER'
          -c:v
          libx264
          -preset
          ultrafast
          -tune
          zerolatency
          -threads
          auto
          -x264-params
          keyint=60:min-keyint=60:scenecut=-1
          -b:v
          4500k
          -maxrate
          6000k
          -bufsize
          8000k
          -pix_fmt
          yuv420p
          -c:a
          aac
          -b:a
          192k
          -ar
          44100
          -ac
          2
          -f
          flv
          INNER
          
          # Add stream URL with key (obfuscated)
          echo "${STREAM_URL}/${STREAM_KEY}" >> "$FFMPEG_OPTS"
          
          # Run FFmpeg with hidden arguments
          echo "ğŸ¬ Starting FFmpeg with hidden arguments..."
          cat "$FFMPEG_OPTS" | xargs ffmpeg -t "$SEGMENT_DURATION" 2> "${TEMP_DIR}/ffmpeg_error_${SEGMENT_NUM}.log"
          FFMPEG_EXIT=$?
          
          if [ $FFMPEG_EXIT -ne 0 ]; then
            echo "âš ï¸ FFmpeg exited with code $FFMPEG_EXIT"
            tail -20 "${TEMP_DIR}/ffmpeg_error_${SEGMENT_NUM}.log"
          fi
          
          # Secure cleanup
          rm -f "$FFMPEG_OPTS" "$FFMPEG_PIPE"
          EOF
          
          chmod 700 pro_secure_stream.sh
          
          # Pro monitoring script
          cat > pro_monitor.sh << 'EOF'
          #!/bin/bash
          
          # PRO VERSION - Advanced Stream Monitoring
          
          TEMP_DIR="$1"
          STREAM_URL="$2"
          TOTAL_DURATION="$3"  # Total stream duration
          SEGMENT_NUM="$4"  # 1 or 2
          
          # Extract server info
          SERVER=$(echo "$STREAM_URL" | sed -E 's|rtmp://([^:/]+).*|\1|')
          PORT=$(echo "$STREAM_URL" | grep -q ":" && echo "$STREAM_URL" | sed -E 's|.*:([0-9]+)/.*|\1|' || echo "1935")
          
          echo "ğŸ“Š PRO Monitor Started - Checking every 30 seconds (Segment $SEGMENT_NUM)"
          
          START_TIME=$(date +%s)
          END_TIME=$((START_TIME + TOTAL_DURATION))
          CHECK_INTERVAL=30
          
          while [ $(date +%s) -lt $END_TIME ]; do
            TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
            
            # Check server connectivity
            if nc -zv -w 5 "$SERVER" "$PORT" 2>/dev/null; then
              echo "$TIMESTAMP: âœ… Stream server connected" >> "${TEMP_DIR}/pro_monitor_${SEGMENT_NUM}.log"
            else
              echo "$TIMESTAMP: âš ï¸ Stream server connection failed" >> "${TEMP_DIR}/pro_monitor_${SEGMENT_NUM}.log"
            fi
            
            # Check FFmpeg process
            if pgrep -f "ffmpeg.*$VIDEO_FILE" > /dev/null; then
              echo "$TIMESTAMP: âœ… FFmpeg running" >> "${TEMP_DIR}/pro_monitor_${SEGMENT_NUM}.log"
              
              # Get FFmpeg CPU usage
              FFMPEG_PID=$(pgrep -f "ffmpeg.*$VIDEO_FILE" | head -1)
              if [ -n "$FFMPEG_PID" ]; then
                CPU_USAGE=$(ps -p "$FFMPEG_PID" -o %cpu | tail -1 | tr -d ' ')
                echo "$TIMESTAMP: ğŸ“Š FFmpeg CPU: ${CPU_USAGE}%" >> "${TEMP_DIR}/pro_monitor_${SEGMENT_NUM}.log"
              fi
            else
              echo "$TIMESTAMP: âŒ FFmpeg not running" >> "${TEMP_DIR}/pro_monitor_${SEGMENT_NUM}.log"
            fi
            
            # Check system resources
            MEM_USAGE=$(free | grep Mem | awk '{print ($3/$2 * 100)}')
            echo "$TIMESTAMP: ğŸ“Š Memory usage: ${MEM_USAGE}%" >> "${TEMP_DIR}/pro_monitor_${SEGMENT_NUM}.log"
            
            sleep $CHECK_INTERVAL
          done
          
          echo "âœ… Monitor completed for segment $SEGMENT_NUM"
          EOF
          
          chmod 700 pro_monitor.sh
          
          # Pro health check script
          cat > pro_health_check.sh << 'EOF'
          #!/bin/bash
          
          TEMP_DIR="$1"
          SEGMENT_NUM="$2"
          
          while true; do
            sleep 60
            
            # Check if FFmpeg is still running
            if ! pgrep -f "ffmpeg.*$VIDEO_FILE" > /dev/null; then
              echo "âš ï¸ FFmpeg died, restarting segment $SEGMENT_NUM..." >> "${TEMP_DIR}/health_${SEGMENT_NUM}.log"
              exit 1
            fi
          done
          EOF
          
          chmod 700 pro_health_check.sh
          
          echo "âœ… PRO secure scripts deployed"

      - name: ğŸš€ Start PRO Stream - First 2 Hours
        run: |
          echo "ğŸ¯ PRO Stream Initializing - Session 1/2 (2 Hours)"
          echo "=============================================="
          echo "âš¡ Security Level: Maximum"
          echo "ğŸ”‘ Stream Key: Hidden from process list"
          echo "â±ï¸  Duration: 2 Hours (7200 seconds)"
          echo "ğŸ“¡ Monitoring: Active (30s intervals)"
          echo "ğŸ¬ Video: ${{ env.VIDEO_FILE }}"
          echo "=============================================="
          
          SEGMENT_DURATION=7200  # 2 hours in seconds
          SEGMENT_NUM=1
          
          # Start pro monitor in background
          ./pro_monitor.sh "${{ env.TEMP_DIR }}" "${{ env.STREAM_URL }}" "$SEGMENT_DURATION" "$SEGMENT_NUM" &
          MONITOR_PID=$!
          
          # Start health checker
          ./pro_health_check.sh "${{ env.TEMP_DIR }}" "$SEGMENT_NUM" &
          HEALTH_PID=$!
          
          # Start hidden stream for first 2 hours
          echo "ğŸ¬ Starting stream segment $SEGMENT_NUM..."
          ./pro_secure_stream.sh "${{ env.TEMP_DIR }}" "${{ env.VIDEO_FILE }}" "${{ env.STREAM_URL }}" "$SEGMENT_DURATION" "$SEGMENT_NUM"
          
          # Stop monitors
          kill $MONITOR_PID $HEALTH_PID 2>/dev/null || true
          
          echo "âœ… First 2-hour segment completed successfully"

      - name: â¸ï¸ Pro Intermission - Connection Reset
        run: |
          echo "ğŸ”„ PRO Intermission - Preparing for second segment"
          echo "=============================================="
          echo "â±ï¸  Short pause: 15 seconds"
          echo "ğŸ”„ Resetting connection for clean start"
          echo "ğŸ“Š Clearing network buffers"
          echo "=============================================="
          
          # Kill any remaining processes
          pkill -f "ffmpeg.*${{ env.VIDEO_FILE }}" 2>/dev/null || true
          pkill -f "pro_monitor" 2>/dev/null || true
          pkill -f "pro_health" 2>/dev/null || true
          
          # Clear network state
          sudo sysctl -w net.ipv4.tcp_tw_reuse=1 > /dev/null 2>&1 || true
          sudo sysctl -w net.ipv4.tcp_fin_timeout=30 > /dev/null 2>&1 || true
          
          # Brief pause to ensure clean state
          sleep 15
          
          # Verify video file still exists and is valid
          if [ ! -f "${{ env.VIDEO_FILE }}" ]; then
            echo "âš ï¸ Video file missing, restoring from backup..."
            if [ -f "${{ env.BACKUP_FILE }}" ]; then
              cp "${{ env.BACKUP_FILE }}" "${{ env.VIDEO_FILE }}"
            else
              echo "âŒ No backup available!"
              exit 1
            fi
          fi
          
          echo "âœ… Ready for second segment"

      - name: ğŸš€ Start PRO Stream - Second 2 Hours
        run: |
          echo "ğŸ¯ PRO Stream Initializing - Session 2/2 (2 Hours)"
          echo "=============================================="
          echo "âš¡ Security Level: Maximum"
          echo "ğŸ”‘ Stream Key: Hidden from process list"
          echo "â±ï¸  Duration: 2 Hours (7200 seconds)"
          echo "ğŸ“¡ Monitoring: Active (30s intervals)"
          echo "ğŸ”„ Fresh connection established"
          echo "=============================================="
          
          SEGMENT_DURATION=7200  # 2 hours in seconds
          SEGMENT_NUM=2
          
          # Start pro monitor in background
          ./pro_monitor.sh "${{ env.TEMP_DIR }}" "${{ env.STREAM_URL }}" "$SEGMENT_DURATION" "$SEGMENT_NUM" &
          MONITOR_PID=$!
          
          # Start health checker
          ./pro_health_check.sh "${{ env.TEMP_DIR }}" "$SEGMENT_NUM" &
          HEALTH_PID=$!
          
          # Start hidden stream for second 2 hours
          echo "ğŸ¬ Starting stream segment $SEGMENT_NUM..."
          ./pro_secure_stream.sh "${{ env.TEMP_DIR }}" "${{ env.VIDEO_FILE }}" "${{ env.STREAM_URL }}" "$SEGMENT_DURATION" "$SEGMENT_NUM"
          
          # Stop monitors
          kill $MONITOR_PID $HEALTH_PID 2>/dev/null || true
          
          echo "âœ… Second 2-hour segment completed successfully"

      - name: ğŸ“Š Generate Stream Statistics
        if: always()
        run: |
          echo "ğŸ“Š PRO Stream Statistics"
          echo "========================"
          
          # Combine and analyze logs
          if [ -d "${{ env.TEMP_DIR }}" ]; then
            echo "ğŸ“ˆ Monitor Log Summary:"
            
            for log in "${{ env.TEMP_DIR }}"/pro_monitor_*.log; do
              if [ -f "$log" ]; then
                echo "  Log: $(basename $log)"
                echo "    Lines: $(wc -l < $log)"
                echo "    Errors: $(grep -c "âŒ\|âš ï¸" $log || echo "0")"
                echo "    OK checks: $(grep -c "âœ…" $log || echo "0")"
              fi
            done
            
            echo -e "\nğŸ“Š Resource Usage:"
            grep "Memory usage" "${{ env.TEMP_DIR }}"/pro_monitor_*.log 2>/dev/null | tail -5 || echo "  No memory data"
            
            echo -e "\nğŸ“‰ FFmpeg Errors (if any):"
            for err in "${{ env.TEMP_DIR }}"/ffmpeg_error_*.log; do
              if [ -f "$err" ] && [ -s "$err" ]; then
                echo "  $(basename $err):"
                tail -5 "$err" | sed 's/^/    /'
              fi
            done
          fi

      - name: ğŸ” PRO Security Audit
        if: always()
        run: |
          echo "ğŸ”’ PRO Security Audit Report"
          echo "============================"
          
          # Check for exposed keys in processes
          echo "ğŸ“‹ Process Security Check:"
          if ps aux 2>/dev/null | grep ffmpeg | grep -v grep | grep -q "${{ secrets.STREAM_KEY }}" 2>/dev/null; then
            echo "âŒ SECURITY ALERT: Stream key exposed in processes!"
          else
            echo "âœ… PASS: No stream key found in processes"
          fi
          
          # Check environment variables
          echo -e "\nğŸŒ Environment Variables Check:"
          if env 2>/dev/null | grep -q "STREAM_KEY"; then
            echo "âŒ SECURITY ALERT: Stream key in environment!"
          else
            echo "âœ… PASS: No stream key in environment"
          fi
          
          # Check file permissions
          echo -e "\nğŸ“ Secure File Permissions:"
          if [ -d "${{ env.TEMP_DIR }}" ]; then
            ls -la "${{ env.TEMP_DIR }}" 2>/dev/null | head -10 || echo "Directory empty"
          else
            echo "Temp directory cleaned"
          fi
          
          # Check bash history
          echo -e "\nğŸ“œ Bash History Check:"
          if [ -f ~/.bash_history ] && grep -q "${{ secrets.STREAM_KEY }}" ~/.bash_history 2>/dev/null; then
            echo "âŒ SECURITY ALERT: Stream key in bash history!"
          else
            echo "âœ… PASS: No stream key in bash history"
          fi
          
          echo -e "\nâœ… PRO Security Audit Complete"

      - name: ğŸ§¹ PRO Secure Cleanup
        if: always()
        run: |
          echo "ğŸ§¹ PRO Secure Cleanup Initialized"
          
          # Kill all processes
          pkill -f "ffmpeg.*${{ env.VIDEO_FILE }}" 2>/dev/null || true
          pkill -f "pro_monitor" 2>/dev/null || true
          pkill -f "pro_secure_stream" 2>/dev/null || true
          pkill -f "pro_health" 2>/dev/null || true
          
          # Secure file deletion
          if [ -d "${{ env.TEMP_DIR }}" ]; then
            echo "ğŸ“ Securely wiping temporary files..."
            
            # Shred sensitive files first
            find "${{ env.TEMP_DIR }}" -type f -name ".stream_key" -exec shred -u {} \; 2>/dev/null || true
            find "${{ env.TEMP_DIR }}" -type f -name ".config" -exec shred -u {} \; 2>/dev/null || true
            
            # Shred log files
            find "${{ env.TEMP_DIR }}" -type f -name "*.log" -exec shred -u {} \; 2>/dev/null || true
            
            # Shred any remaining files
            find "${{ env.TEMP_DIR }}" -type f -exec shred -u {} \; 2>/dev/null || true
            
            # Remove directory
            rm -rf "${{ env.TEMP_DIR }}"
            echo "âœ… Temporary directory securely wiped"
          fi
          
          # Clear sensitive variables
          unset STREAM_KEY
          unset INPUT_STREAM_KEY
          
          # Clear command history
          history -c 2>/dev/null || true
          > ~/.bash_history 2>/dev/null || true
          
          echo "âœ… PRO Secure Cleanup Complete"

      - name: ğŸ“Š PRO Stream Summary
        if: always()
        run: |
          echo "ğŸ¯ PRO STREAM - FINAL REPORT"
          echo "============================"
          echo "âœ… Status: ${{ job.status }}"
          echo "â±ï¸  Total Runtime: 4 Hours (2h + 2h)"
          echo "ğŸ”’ Security: Enterprise Grade"
          echo "ğŸ“¡ Monitoring: Real-time Health Checks (30s intervals)"
          echo "ğŸ”„ Segments: Two 2-hour streams with reset"
          echo "ğŸ¬ Video: Continuous loop with connection reset"
          echo "ğŸ“ File ID: ${{ env.FILE_ID }}"
          echo "============================"
          
          # Add timestamp
          echo "ğŸ“… Completed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "ğŸƒ Run ID: ${{ github.run_id }}"
          echo "============================"

      - name: ğŸ“¤ Upload PRO Debug Logs (if failed)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: pro-debug-logs-${{ github.run_id }}
          path: |
            ${{ env.TEMP_DIR }}/*.log
            ${{ env.TEMP_DIR }}/pro_monitor_*.log
            ${{ env.TEMP_DIR }}/ffmpeg_error_*.log
          retention-days: 7
          if-no-files-found: warn
          compression-level: 6
